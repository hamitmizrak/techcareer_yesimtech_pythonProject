# Python
[GitHub Address]()
---

## Git 
```sh 
git init 
git add .
git commit -m "message"
git clone https://github.com/hamitmizrak/techcareer_yesimtech_pythonProject.git
```

## Python Common Rules
```sh
PEP 8 : Python Enchancement Proposal: Kodların okunabilirliğini, hatasız çalıştırmak için kurallar bütüdür.
1-) Kod düzeni ve Girinti: Standart girinti: 4 boşluktur.
2-) Bir satırın uzunluğu en fazla 79 karakter olması gerekiyor.
3-) Fonksiyonlar ile sınıflar arasında 2 boşluk olması gerekiyor.
4-) Yorumlamalar anlaşılır kısa ve öz olsun tek satır bile olsa yazın.
5-) Docstring(Belgelendirme Stringleri) """ """
6-) Fonksiyon, değişken isimleri snake_case kuralına göre yazınız.
7-) Const-Permanent sabir değişkenler BÜYÜK_HARFLERLE_YAZINIZ.
8-) Değişkenlerde global değişken varsa  `global` keyword yazınız ancak bu pekte önerilmez.
9-) string için çift veya tek kullanamabilirsiniz.
```



## Best practice
```sh 
#####################################################################################
#### best practices #################################################################
"""
1-) Noktalı virgül yazabilirsiniz veya yazmayabilirsiniz.
Python, noktalı virgül (;) kullanımını destekler, ancak bu zorunlu değildir ve Python topluluğunda pek tercih edilmez. 
Python'un tasarım felsefesi "okunabilirliği artırmak" olduğu için satır sonlarını belirtmek için yeni satır kullanmak daha yaygındır.

2-) Python’da değişken isimleri büyük ve küçük harfe duyarlıdır. snake_case yazım şeklinde devam edelim.  
Python'da değişken isimlendirme konvansiyonları için snake_case kullanımı yaygın olarak tercih edilir. 
Ancak, camelCase de kullanılabilir, ancak bu genellikle Python topluluğu tarafından yaygın bir standart olarak görülmez.

3-) Python'da girintileme zorunludur. Girinti, bir kod bloğunu belirtmek için kullanılır ve doğru girintileme olmadan Python kodu hata verecektir.
- Standart girinti genellikle 4 boşluk karakteri ile yapılır. 
Tab tuşunu kullanmak yerine boşluk karakterleri kullanmak daha yaygın ve önerilen bir yaklaşımdır.
if x > 10:
    print("x is greater than 10")   4 boşluk kullanılarak girintilendi
4-) Bir satırın uzunluğu en fazla 79 karakter olmalıdır. 
5-) Fonksiyonlar ve sınıflar arasında iki boş satır bırakılmalıdır.

def first_function():
    pass


def second_function():
    pass
    
6-) Fonksiyon ve değişken isimleri küçük harflerden oluşmalı ve kelimeler arasına alt çizgi (_) konulmalıdır (snake_case).

7-) Sabit değerler için kullanılan değişken isimleri büyük harflerle yazılmalıdır. 
MAX_CONNECTIONS = 100

8-) Global değişken kullanılması gerekiyorsa, global anahtar kelimesiyle belirtilmelidir. 
global total
total = 0

9-) - Python'da listeleri daha kısa ve verimli bir şekilde oluşturmak için list comprehension kullanmak iyi bir uygulamadır.
squares = [x  2 for x in range(10)]
10-) Kod modüllere ayrılmalı, yani işlevler küçük ve tek bir görevi yerine getirecek şekilde yazılmalıdır.

11-) Koşullu ifadelerde gereksiz boolean ifadelerden kaçının. 

Örneğin if x == True: yerine if x: yazmak daha kısa ve anlaşılırdır.

12-) Döngüler yazarken Python'un sunduğu iterator ve generator yapılarından faydalanmak, kodu daha verimli ve temiz hale getirir.
for i in range(10):
    print(i)


"""
```

## Escape Characters
```sh 
# Escape Character
"""
Kaçış karakterleri, programlama dillerinde özel bir anlam ifade eden ve genellikle bir karakterin, 
komutun veya sembolün, sıradan bir metin içinde kullanılması gerektiğinde ortaya çıkan problemleri 
çözmek için kullanılan karakter dizileridir

\r	Satır başı (Carriage Return)
\t	Sekme (tab)
\n	Yeni satır
"""

```

## Python
```sh 
Django      : python-3.10.0-amd64
PythonPure  : python-3.13.1-amd64
Mongo       : 
```

## Python Access Modifier
```sh
Python'da, bir sınıfın alanlarının **public**, **private**, veya **protected** olduğunu anlamak için şu kuralları takip edebilirsiniz:

### 1. **Public** (Genel erişim):
- Bir değişken veya metoda doğrudan erişim mümkündür.
- İsimlendirmede herhangi bir özel işaret kullanılmaz.
- Örnek: `self.yil` ve `self.renk` bu sınıfta public.

### 2. **Protected** (Korunan):
- Protected üyeler, `_` (tek alt çizgi) ile başlar.
- Bu üyeler, doğrudan sınıfın içinde ve bu sınıftan türeyen alt sınıflarda erişilebilir.
- Python'da bu, yalnızca bir "anlaşma" olarak kabul edilir; teknik olarak, bu üyelere dışarıdan erişim yine de mümkündür.
- Örnek: `self._model` bu sınıfta protected.

### 3. **Private** (Özel erişim):
- Private üyeler, `__` (çift alt çizgi) ile başlar.
- Python'da bu isimler "name mangling" denilen bir yöntemle değiştirilir, böylece doğrudan erişim zorlaşır.
- Örneğin, `self.__marka`, aslında `Araba._Araba__marka` olarak saklanır.
- Private üyelere sınıf dışından doğrudan erişim sağlanamaz; yalnızca getter ve setter gibi yöntemlerle erişilir.
- Örnek: `self.__marka` bu sınıfta private.

---

### Sınıfınızda Alanların Durumu:

- **Public**: `self.yil`, `self.renk`
- **Protected**: `self._model`
- **Private**: `self.__marka`

### Erişim Kontrollerinin Testi:

Bu durumları görmek için aşağıdaki kodu çalıştırabilirsiniz:

```python
araba = Araba()

# Public erişim
print(araba.yil)  # Doğrudan erişilebilir
print(araba.renk)  # Doğrudan erişilebilir

# Protected erişim
print(araba._model)  # Teknik olarak erişilebilir, ancak önerilmez

# Private erişim
try:
    print(araba.__marka)  # AttributeError: 'Araba' object has no attribute '__marka'
except AttributeError as e:
    print(e)

# Private doğru erişim
print(araba.get_marka())  # Doğru yol
```

Sonuçlar bu kuralları doğrular. Eğer başka bir konuda detay isterseniz, lütfen belirtin!
```

## Python Enum
```sh 
Python'da **Enum** (Enumeration), birbirleriyle ilişkili sabit değerleri gruplamak ve yönetmek için kullanılan bir veri yapısıdır. Enum'lar, kodun okunabilirliğini artırır ve "sihirli sayılar" olarak bilinen, anlamı belirsiz sabit değerlerin kullanımını önler. Python'da `enum` modülü, bu tür veri yapıları oluşturmak için gerekli araçları sağlar.

### Enum Nedir?

Enum, sembolik isimlerin benzersiz değerlere bağlandığı bir veri yapısıdır. Bu yapı, belirli bir değişkenin alabileceği sınırlı ve önceden tanımlı değerleri temsil etmek için kullanılır. Örneğin, bir trafik ışığının durumları (`KIRMIZI`, `SARI`, `YEŞİL`) veya haftanın günleri (`PAZARTESİ`, `SALI`, vb.) Enum ile temsil edilebilir.

### Python'da Enum Nasıl Oluşturulur?

Python'da Enum oluşturmak için `enum` modülünden `Enum` sınıfı kullanılır. İki temel yöntem mevcuttur: sınıf sözdizimi ve fonksiyonel API.

**1. Sınıf Sözdizimi ile Enum Oluşturma:**

```python
from enum import Enum

class Renk(Enum):
    KIRMIZI = 1
    YESIL = 2
    MAVI = 3
```

Bu örnekte, `Renk` adında bir Enum sınıfı oluşturulmuş ve her bir renk bir sayısal değere atanmıştır.

**2. Fonksiyonel API ile Enum Oluşturma:**

```python
from enum import Enum

Renk = Enum('Renk', {'KIRMIZI': 1, 'YESIL': 2, 'MAVI': 3})
```

Bu yöntem, dinamik olarak Enum oluşturmak için kullanılır.

### Enum Üyelerine Erişim ve Kullanım

Enum üyelerine isimleri veya değerleri aracılığıyla erişilebilir:

```python
# İsim ile erişim
print(Renk.KIRMIZI)        # Renk.KIRMIZI
print(Renk.KIRMIZI.name)   # KIRMIZI
print(Renk.KIRMIZI.value)  # 1

# Değer ile erişim
print(Renk(2))             # Renk.YESIL
```

### Enum Üyeleri Üzerinde Döngü

Enum üyeleri üzerinde döngü yaparak tüm üyelere erişebilirsiniz:

```python
for renk in Renk:
    print(f"{renk.name} = {renk.value}")
```

### Enum ile Karşılaştırma

Enum üyeleri, kimlik (`is`) veya eşitlik (`==`) operatörleri ile karşılaştırılabilir:

```python
if Renk.KIRMIZI == Renk(1):
    print("Eşit")
```

### Enum Sınıflarının Özelleştirilmesi

Enum sınıflarına ek yöntemler ekleyerek davranışlarını özelleştirebilirsiniz:

```python
from enum import Enum

class Islem(Enum):
    TOPLA = '+'
    CIKAR = '-'
    CARP = '*'
    BOL = '/'

    def uygulama(self, a, b):
        if self == Islem.TOPLA:
            return a + b
        elif self == Islem.CIKAR:
            return a - b
        elif self == Islem.CARP:
            return a * b
        elif self == Islem.BOL:
            return a / b

# Kullanım
sonuc = Islem.CARP.uygulama(4, 5)
print(sonuc)  # 20
```

### Otomatik Değer Atama

`auto()` fonksiyonu kullanılarak Enum üyelerine otomatik olarak artan değerler atanabilir:

```python
from enum import Enum, auto

class Hayvan(Enum):
    KEDI = auto()
    KOPEK = auto()
    AT = auto()

print(Hayvan.KEDI.value)  # 1
print(Hayvan.KOPEK.value) # 2
```

### Enum ve Bit İşlemleri

`Flag` veya `IntFlag` sınıfları kullanılarak bit düzeyinde işlemler yapabilen Enum'lar oluşturulabilir:

```python
from enum import IntFlag

class Izin(IntFlag):
    OKU = 1
    YAZ = 2
    CALISTIR = 4

izinler = Izin.OKU | Izin.YAZ
print(izinler)  # Izin.OKU|YAZ
```

### Enum Kullanımının Avantajları

- **Okunabilirlik:** Kodun anlaşılabilirliğini artırır.
- **Bakım Kolaylığı:** Sabit değerlerin merkezi bir yerde tanımlanması, kod bakımını kolaylaştırır.
- **Hata Önleme:** Geçersiz değerlerin kullanılmasını engelleyerek hataları azaltır.
- **Tür Güvenliği:** Belirli bir değişkenin sadece önceden tanımlanmış değerleri almasını sağlar.

### Enum ile İlgili Dikkat Edilmesi Gerekenler

- Enum üyeleri değiştirilemez (immutable) ve yeniden atanamaz.
- Enum üyeleri arasında karşılaştırma yaparken, aynı Enum sınıfına ait olmalarına dikkat edilmelidir.

Enum'lar, Python'da kodunuzu daha yapılandırılmış, okunabilir ve güvenilir hale getirmek için güçlü bir araçtır. Özellikle sınırlı ve sabit değer kümeleriyle çalışırken kullanımı önerilir.

Daha fazla bilgi için Python'un resmi belgelerine başvurabilirsiniz: 

Ek olarak, aşağıdaki video da konuyu gör 
```

## Python Loglama
```sh 
Bu kod satırı, Python'daki **logging** modülünü kullanarak bir günlük (log) sistemi yapılandırmak için kullanılan bir komuttur. Detaylı olarak açıklayalım:

---

### **Kodun Genel Yapısı**
```python
logging.basicConfig(
    filename='araba_log.txt',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
```

Bu yapı, logların (günlüklerin):
1. **Nereye kaydedileceği** (dosya veya konsol),
2. **Hangi önem seviyelerinin kaydedileceği**,
3. **Log mesajlarının formatı** gibi özellikleri belirler.

---

### **Parametrelerin Açıklaması**

#### 1. **`filename='araba_log.txt'`**
- **Anlamı:** 
  - Logların bir dosyaya yazılmasını sağlar.
  - `filename` parametresi ile logların kaydedileceği dosyanın adı belirtilir.
  - Bu durumda loglar, `araba_log.txt` isimli dosyaya kaydedilecektir.
- **Dosya Yolu:**
  - Eğer sadece dosya adı belirtilmişse (ör. `'araba_log.txt'`), dosya çalıştırılan dizine kaydedilir.
  - İsteğe bağlı olarak tam bir dosya yolu verilebilir:
    ```python
    filename='/path/to/araba_log.txt'
    ```

#### 2. **`level=logging.INFO`**
- **Anlamı:** 
  - Kaydedilecek logların minimum önem seviyesini belirler.
  - `logging.INFO` demek, **INFO** ve daha yüksek seviyeli logların kaydedileceği anlamına gelir.
- **Log Seviyeleri:**
  - Python'da log seviyeleri şu şekilde sıralanır (önem derecesine göre):
    - **DEBUG (10):** Hata ayıklama bilgileri (genelde geliştiriciler içindir).
    - **INFO (20):** Genel bilgi mesajları.
    - **WARNING (30):** Potansiyel sorunları belirten uyarılar.
    - **ERROR (40):** Hatalar.
    - **CRITICAL (50):** Kritik hatalar veya sistemin çökmesine neden olabilecek durumlar.
  - Örneğin:
    ```python
    logging.basicConfig(level=logging.WARNING)
    ```
    Bu durumda sadece **WARNING**, **ERROR**, ve **CRITICAL** seviyesindeki loglar kaydedilir.

#### 3. **`format='%(asctime)s - %(levelname)s - %(message)s'`**
- **Anlamı:** 
  - Log mesajlarının biçimini tanımlar.
  - `%` ile başlayan ifadeler, logların hangi bilgileri içereceğini belirtir.

- **Formatın Detayları:**
  - `%(asctime)s`: Log mesajının oluşturulduğu tarih ve saat (ör. 2025-01-16 14:00:23,456).
  - `%(levelname)s`: Log seviyesinin adı (ör. INFO, WARNING, ERROR).
  - `%(message)s`: Kullanıcı tarafından sağlanan log mesajı.

- **Örnek Çıktı:**
  ```plaintext
  2025-01-16 14:00:23,456 - INFO - Araba hızlandırıldı
  ```

- **Diğer Format Parametreleri:**
  - `%(name)s`: Logger'ın adı.
  - `%(filename)s`: Log mesajını üreten dosyanın adı.
  - `%(lineno)d`: Log çağrısının yapıldığı satır numarası.
  - `%(funcName)s`: Log çağrısının yapıldığı fonksiyon adı.

#### **Örnek Alternatif Format:**
```python
format='%(levelname)s:%(message)s (%(asctime)s)'
```
Çıktı:
```plaintext
INFO:Araba hızlandırıldı (2025-01-16 14:00:23,456)
```

---

### **Örnek Kullanım**
```python
import logging

# Logging yapılandırması
logging.basicConfig(
    filename='araba_log.txt',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# Log mesajları
logging.debug("Bu bir debug mesajıdır.")
logging.info("Araba çalıştırıldı.")
logging.warning("Motor yağı düşük!")
logging.error("Motor arızası meydana geldi.")
logging.critical("Motor tamamen durdu!")
```

**`araba_log.txt` Dosyası İçeriği:**
```plaintext
2025-01-16 14:00:23,456 - INFO - Araba çalıştırıldı.
2025-01-16 14:00:23,457 - WARNING - Motor yağı düşük!
2025-01-16 14:00:23,458 - ERROR - Motor arızası meydana geldi.
2025-01-16 14:00:23,459 - CRITICAL - Motor tamamen durdu!
```

---

### **Sıkça Sorulan Sorular**

#### 1. **Loglar hem dosyaya hem de konsola nasıl yazdırılır?**
```python
import logging

# Loglama yapılandırması
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# Dosyaya ek logger
file_handler = logging.FileHandler('araba_log.txt')
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
file_handler.setFormatter(formatter)

# Root logger'a ekleme
logger = logging.getLogger()
logger.addHandler(file_handler)

# Log mesajları
logger.info("Araba çalıştırıldı.")
```

---

#### 2. **Varolan bir dosyaya log eklemek yerine dosyayı sıfırdan başlatabilir miyim?**
Varsayılan olarak `logging.basicConfig` logları **ekleme** (append) modunda açar. Eğer dosyayı sıfırdan başlatmak istiyorsanız, `filemode='w'` parametresini kullanabilirsiniz:

```python
logging.basicConfig(
    filename='araba_log.txt',
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filemode='w'  # Dosyayı sıfırdan başlatır
)
```

---

Bu bilgilerle `logging.basicConfig` yapılandırmasını ihtiyacınıza göre özelleştirebilirsiniz. 😊
```

## Plugin
```sh 
Evet, PyCharm'da Python kodlarındaki hataları daha detaylı şekilde tespit edebilmek için kullanabileceğiniz çeşitli **plugin'ler** ve araçlar vardır. İşte en çok kullanılan ve faydalı olanlar:

---

### **1. Pylint**
- **Açıklama**: Python kodunuzdaki hataları ve kod stili (PEP8) uyumsuzluklarını kontrol eder.
- **Kurulum**:
  - PyCharm terminalinde:
    ```bash
    pip install pylint
    ```
  - PyCharm'da etkinleştirmek için:
    1. **File > Settings > Plugins** bölümüne gidin.
    2. **Marketplace** sekmesinden "Pylint" arayın ve yükleyin.
    3. **Settings > Tools > Pylint** bölümünde yapılandırmayı tamamlayın.
- **Özellikler**:
  - Kod stili uyumluluğu.
  - Olası hatalar ve kötü kod yapıları hakkında detaylı öneriler.

---

### **2. Flake8**
- **Açıklama**: Python kodu için popüler bir linting aracı olup, PEP8'e uyumlu bir kod yazmanıza yardımcı olur.
- **Kurulum**:
  - PyCharm terminalinde:
    ```bash
    pip install flake8
    ```
  - **File > Settings > Plugins** kısmında "Flake8" plugin’ini arayarak yükleyebilirsiniz.
- **Özellikler**:
  - Kod hatalarını ve stil problemlerini tespit eder.
  - Hatalar için kısa açıklamalar sağlar.

---

### **3. Black (Kod Formatlayıcı)**
- **Açıklama**: Python kodunu otomatik olarak formatlayan bir araçtır. Kodunuzu daha okunabilir ve düzenli hale getirir.
- **Kurulum**:
  - PyCharm terminalinde:
    ```bash
    pip install black
    ```
  - Plugin olarak "Black Formatter" isimli bir eklenti arayabilirsiniz.
- **Özellikler**:
  - Kod formatlama hatalarını düzeltir.
  - PEP8 standartlarına uygun hale getirir.

---

### **4. mypy**
- **Açıklama**: Python'da statik tip kontrolü için kullanılır. Eğer kodunuzda `type hints` (örn: `int`, `str`) kullanıyorsanız, `mypy` sayesinde tip uyumsuzluklarını tespit edebilirsiniz.
- **Kurulum**:
  - PyCharm terminalinde:
    ```bash
    pip install mypy
    ```
  - **Settings > Plugins** kısmında "Mypy" eklentisini arayarak yükleyebilirsiniz.
- **Özellikler**:
  - Tip kontrolü yapar.
  - Daha güvenilir ve sağlam bir kod yazmanızı sağlar.

---

### **5. Sonarlint**
- **Açıklama**: Kodu analiz ederek güvenlik açıklarını, hataları ve kod kokularını (code smells) bulur.
- **Kurulum**:
  - **Settings > Plugins > Marketplace** sekmesinde "SonarLint" arayın ve yükleyin.
- **Özellikler**:
  - Güvenlik açıklarını ve hataları gerçek zamanlı tespit eder.
  - Hem yeni başlayanlar hem de profesyoneller için uygundur.

---

### **6. Codota (Tabnine)**
- **Açıklama**: Yapay zeka destekli bir araç olup, kod tamamlama ve hata önerileri sunar.
- **Kurulum**:
  - **Settings > Plugins > Marketplace** sekmesinde "Tabnine" veya "Codota" arayın ve yükleyin.
- **Özellikler**:
  - Kod tamamlama ve hata tespiti.
  - Daha hızlı ve akıllı kod yazımı.

---

### **7. ESLint (Python için uyarlanmış araçlar)**
- **Açıklama**: Python kodunu analiz etmek için birden fazla linter'ı destekleyen araçtır.
- **Kurulum**:
  - PyCharm'dan Flake8 ile birlikte kullanılabilir.
  - **Settings > Plugins > Marketplace** kısmından yükleyin.
- **Özellikler**:
  - Kod düzenleme ve hataların raporlanması.

---

### **8. PyCharm Yerleşik Denetimleri**
- PyCharm'ın kendi yerleşik **inspections** özelliğini kullanabilirsiniz.
  - **Settings > Editor > Inspections** kısmında Python ile ilgili tüm hataları aktif hale getirin.
  - Hatalar kod yazarken gerçek zamanlı olarak altı çizili şekilde gösterilir.

---

### Özet: Hangi Plugin Kullanılmalı?
Eğer detaylı hata kontrolü istiyorsanız:
- **Pylint** ve **Flake8** bir arada kullanabilirsiniz.
- **SonarLint** ile güvenlik açıklarına odaklanabilirsiniz.
- Kod formatlama için **Black** çok işinize yarayacaktır.

Bu eklentilerden biri ya da birkaçını kurarak PyCharm deneyiminizi geliştirebilirsiniz. Daha fazla yardıma ihtiyacınız olursa, kurulum veya ayarlar konusunda destek verebilirim!
```


## Python
```sh 
```

